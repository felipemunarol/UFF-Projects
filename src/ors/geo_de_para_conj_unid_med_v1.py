# -*- coding: utf-8 -*-
"""geo_de_para_conj_unid_med_v1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ya5LJhHwoULLQ2fAvfbOjMKrTrJcaqt2

Realiza o geoprocessamento (De-para) com a união entre as informações de Conjuntos de Unidades Consumidoras e as informações de unidades de medição do INMET

As unidades geograficas sao consideradas como as areas em que sao divididos um territorio (neste presente trabalho). Para serem analisadas as condicoes climaticas nestas unidades é necessario que sejam coletadas
as informacoes de medicoes meteorologicas nessas regioes. No brasil, o Immet é um dos orgãos de esfera federal que realizam essas medições. As medicoes são realizadas por unidades meteorologicas que estao presentes
no territorio brasileiro em diferentes areas. Para se ter uma métrica meteorológica em cada unidade geográfica é necessario portanto verificar as medidas que foram relizadas nestas regioes. Dependendo da divisao do território,
em contrapartida é sabido que nem todas as suas partes apresentam unidades de medições, dentro dos seus limites. Dessa forma, considerando a ausência de informações meteorológicas em todas as unidades geográficas e que estas medições se assemelham mais em
regiões que estão próximas, na ausencia destas medidas em um destes territorios a melhor informacao é a de seus territorios mais proximos.

Requirements
"""

! pip install geocoder
! pip install geopandas

"""Librarys"""

import csv
import ast
import pandas as pd
import os
import geocoder
import geopandas as gpd
import numpy as np
import matplotlib.pyplot as plt

from geopy.geocoders import Nominatim

# Conecta o serviço com o Drive
from google.colab import drive
drive.mount('/content/drive')

# Root Path
os.environ['ROOT'] = '/content/drive/MyDrive/Mestrado/Ordens_servico/'
base_path = os.environ.get("ROOT")

year = 2022

# Raiz
! ls '$ROOT/Ordens_servico/Dados'

"""## Dados Meteorologicos"""

# Leitura dos dados entre processados
meteorologia_result = pd.read_csv(base_path + "Ordens_servico/meteorologia_raw_{}.csv".format(year))

"""## Inclui os dados de conjuntos nas informacoes meteorologicas"""

meteorologia_result

# We have 574 measuring units
unidades_de_medicao = meteorologia_result.drop_duplicates("unidademedicao")[["unidademedicao", "latitude", "longitude"]]
unidades_de_medicao

# Transform the coodinate to a point (lat, long)
unidades_de_medicao["point"] = gpd.GeoSeries.from_xy(unidades_de_medicao.longitude, unidades_de_medicao.latitude)
unidades_de_medicao["point"]

# Plot the mensure units
gdf = gpd.GeoDataFrame(
    unidades_de_medicao, geometry=unidades_de_medicao["point"],
)
gdf.plot(figsize=(20,10), cmap='OrRd', markersize=9)
# gdf.plot(figsize=(20,10), color='green', markersize=9)

# Read the geografic units data. (information about the geographic territories)
de_para_conj = gpd.read_file(base_path + "Ordens_servico/de_para_und_cons_.json")
de_para_conj

de_para_conj.plot(figsize=(20,10))

# plot the units of mensures overlap on the sets of clients geographic regions
fig, ax = plt.subplots(figsize=(12, 8))

gdf.plot(figsize=(20,10), cmap='OrRd', ax=ax)
# de_para_conj.plot(figsize=(20,10), ax=ax)
de_para_conj.plot(figsize=(20,10), ax=ax, color='white', edgecolor='black', alpha=0.4)

"""For each polygon, check if have a unit inside, if not get the closer unit"""

# Set the lists the contain the mensuring units points (lat, long)
points = unidades_de_medicao.point
units_med = unidades_de_medicao.unidademedicao

# Test a case for one territory unit (test if the meteorology mensuring unit is in the territory unit)
unidades_de_medicao["point"].iloc[0].intersects(de_para_conj["geometry"].iloc[4])

# Test the distance return
polygons[4].distance(unidades_de_medicao["point"].iloc[0])

# Function that for each polygon, check if have a unit inside, if not, get the closer unit

def ident_mensu_unit(serie):
  polygon = serie.geometry
  ds_conj = serie.DscConjUndConsumidoras

  list_units = []
  distance = 0
  for point, unit_med in zip(points, units_med):
    # check if the point intercept the polygon
    if point.intersects(polygon):
      print("unit founded")
      list_units.append(unit_med)

  # if not founded mensuring unit (point), check the closer one
  if not list_units:
    print("unit not founded")
    # get distances
    distance_point = {}
    for point, unit_med in zip(points, units_med):
      distance_point[unit_med] = polygon.distance(point)
    # get the unit with the min distance
    list_units.append(min(distance_point, key=distance_point.get))
    distance = distance_point[min(distance_point, key=distance_point.get)]

  return list_units, distance

de_para_conj[["units_med", "distance"]] = de_para_conj.apply(ident_mensu_unit, axis=1, result_type="expand")

de_para_conj

# Check quantity of geographic territorys without unit (the inference was made)
de_para_conj[de_para_conj["distance"] != 0]

# Transform all geographic territorys with more than one mensuring unit in two lines
de_para_conj = de_para_conj.explode("units_med")

de_para_conj

de_para_conj.to_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_.json", driver='GeoJSON')

