# -*- coding: utf-8 -*-
"""geo_de_para_conj_municipios.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AowfORj6WbVvILMbiGQtdKbcE60JVqBT

Inclui nos dados de unidades geograficas (conjuntos), os respectivos municipios em que estas estao contidas. Para verificar a condição de pertencimento (estar contido) deve-se ser definida a regra de avaliacao pois como sao dois poligonos (unidade geografica e municipio) formados por "infinitos" pontos não há uma única forma de regra. Para este trabalho é considerado o ponto central do poligono como representacao geografica da localização desta entidade e avaliado se este ponto (lat, long) esta contido dentro do municipio definido pelo IBGE.
"""

! pip install geopandas

"""Realiza o de-para de identificador do conjunto e a o municipio a qual pertence. Dado que um conjunto pode atraversar diversos municipios, é utilizado o ponto central do conjunto como o seu ponto referencia.


"""

import pandas as pd
import os
import sys
import ast

import requests
import csv
import geopandas as gpd
import codecs

# Conecta o serviço com o Drive
from google.colab import drive
drive.mount('/content/drive')

pd.set_option('display.max_columns', None)

# Conecta o serviço com o Drive
from google.colab import drive
drive.mount('/content/drive')

os.environ['ROOT'] = '/content/drive/MyDrive/Mestrado/Ordens_servico/'
base_path = os.environ.get("ROOT")

de_para_conj = gpd.read_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_.json", driver='GeoJSON')

de_para_conj

# Plot of the sets area

de_para_conj.plot(figsize=(12,8))

gpd_mun = gpd.read_file(base_path + "/Ordens_servico/geo_reference/BR_Municipios_2022.shp")

gpd_mun.plot(figsize=(12,8))

gpd_mun

de_para_conj.centroid.plot(marker='*', color='green', markersize=5, figsize=(12, 8))

gpd_mun.plot(figsize=(12, 8))

base = gpd_mun.plot(figsize=(12, 8))

base = de_para_conj.centroid.plot(marker='*', color='green', markersize=5, figsize=(12, 8), ax=base)

"""## Inclui o municipio na base de conjuntos em que o centroide esta contido"""

gpd_mun

polygons = gpd_mun.geometry
ds_munic = gpd_mun.NM_MUN
ds_uf = gpd_mun.SIGLA_UF


# Convert the cordinate to a flat position, to find the center, then convert it back
de_para_conj['point'] = de_para_conj.to_crs('+proj=cea').centroid.to_crs(de_para_conj.crs)

# Funcao que acrescenta a cada conjunto o municipio em que seu centroide esta contido

def ident_conj(point):

  for polygon, munic, uf in zip(polygons, ds_munic, ds_uf):
    if point:
      if point.intersects(polygon):
        return (munic, uf)

def fillnone(value):
  print(value)
  if not value:
    return(None, None)
  else:
    return(value)



de_para_conj["ds_munic_uf"] = de_para_conj["point"].apply(ident_conj)
# Turn None in a vector for numpy understand the shape of vector (n, 2)
de_para_conj["ds_munic_uf"] = de_para_conj["ds_munic_uf"].apply(fillnone)
de_para_conj[["ds_munic", "ds_uf"]] = de_para_conj.ds_munic_uf.tolist()
de_para_conj["ds_munic_uf"]

de_para_conj

de_para_conj[de_para_conj.ds_munic.isnull()].drop_duplicates('DscConjUndConsumidoras')   # verifica se existe algum nulo nos dados de geometria

de_para_conj[["IdeConjUndConsumidoras", "DscConjUndConsumidoras", "geometry", "ds_munic", "ds_uf", "MUN_MINIMUM_BOUND_RADIO", "MUN_NUMBER_OF_BOUNDARYS", "AREA"]].to_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_mun.json", driver='GeoJSON')

