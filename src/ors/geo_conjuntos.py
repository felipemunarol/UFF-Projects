# -*- coding: utf-8 -*-
"""geo_conjuntos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16X0DkC6_PufyY6jujYB6IYTF8aKgpusx

Le as informacoes de conjunto e cria algumas caracteristicas relativas a sua regiao geografica (area, perimetro, etc). Persiste os dados ao final.
"""

! pip install geotable  # Library to read the kmz file
! pip install geopandas # https://geopandas.org/en/stable/docs/user_guide/io.html

# libraries
import csv
import pandas as pd
import os
# import ckan
import requests
import geopandas as gpd
import urllib
import time
import geotable
import sys
import ast
import codecs
from zipfile import ZipFile
import fiona

pd.set_option('display.max_columns', None)

# Conecta o serviÃ§o com o Drive
from google.colab import drive
drive.mount('/content/drive')

os.environ['ROOT'] = '/content/drive/MyDrive/Mestrado/Ordens_servico/'
base_path = os.environ.get("ROOT")

year = 2021

# Raiz
! ls '/content/drive/MyDrive/Mestrado/Ordens_servico/'

"""## Geoinformation of sets"""

# https://pypi.org/project/geotable/ -  open a geotable with geopandas
t = geotable.load(base_path + "Ordens_servico/AHE_DOWN_LayerToKML.kmz")

from geotable.projections import LONGITUDE_LATITUDE_PROJ4
t.save_shp(base_path + "Ordens_servico/AHE_DOWN_LayerToKMLSHP.zip", target_proj4=LONGITUDE_LATITUDE_PROJ4)

t_g = gpd.read_file(base_path + "Ordens_servico/AHE_DOWN_LayerToKMLSHP.zip")

t_g.plot(figsize=(20,10))

# Pass the id of the set to integer
t_g["Name"] = t_g.Name.astype("int")
# validacao de um conjunto
t_g[t_g.Name == 15587]

t_g[t_g.Name==14843].geometry.iloc[0]

t_g[t_g.Name==14843].geometry.iloc[1]

# Foram encontrados no arquivo KML casos repetidos que sao retirados da base
t_g = t_g.drop_duplicates('Name')

# Exsistem 3636 bases mapeadas pelo SIGEL
t_g

de_para_conj = pd.read_csv(base_path + "Ordens_servico/de_para_und_cons.csv")
de_para_conj

# Existem 3125 conjuntos em que temos o identificador e a geometria mapeados
de_para_conj_ = t_g.merge(de_para_conj, left_on="Name", right_on="IdeConjUndConsumidoras", how='inner')
de_para_conj_

de_para_conj_.to_file(base_path + "Ordens_servico/de_para_und_cons_.json", driver='GeoJSON')

"""## Inclui as informacoes geograficas (caracteristica geograficas) nas informacoes de conjuntos

Sao adicionados o raio, o perimetro e a area de cada conjunto

---


"""

# Reference to CRS Coordinate System - https://rspatial.org/terra/spatial/6-crs.html

de_para_conj_ = gpd.read_file(base_path + "Ordens_servico/de_para_und_cons_.json", driver='GeoJSON')

# Alguns conjuntos apresentam a mesma descricao porem com IDs e coordenadas geograficas diferentes. Esses dados sao retirados
de_para_conj_[de_para_conj_.DscConjUndConsumidoras == "BOM JARDIM"].plot()

# 94 conjuntos dos 3125 apresentam dados com nomes repetidos - Casos retirados
de_para_conj_repeated = de_para_conj_.groupby(["DscConjUndConsumidoras"])["geometry"].count().sort_values(ascending=False)
de_para_conj_repeated = de_para_conj_repeated[de_para_conj_repeated > 1]
de_para_conj_ = de_para_conj_[~de_para_conj_.DscConjUndConsumidoras.isin(de_para_conj_repeated.index)]
de_para_conj_

# Faz o processomento espacial de buffer das coordenadas geograficas de latitude e longitude
# Aplicacao do buffet
# gdf = geopandas.GeoDataFrame(df, geometry=geopandas.points_from_xy(df.LONGITUDE, df.LATITUDE), crs="EPSG:5880")
# gdf = gdf.to_crs("EPSG:5880")
# gdf["buffered"] = gdf.buffer(1000000)
# # https://reconshell.com/wp-content/uploads/2022/09/Machine_Learning_on_Geographical_Data_Using_Python.pdf
# gdf[["geometry", "buffered"]]

# Returns a Series with the radio of the minumum bounding circle that contain it
de_para_conj_["MUN_MINIMUM_BOUND_RADIO"] = de_para_conj_.geometry.minimum_bounding_radius()

# Returns a Series containing the length of each geometry expressed in the units of the CRS. - https://geopandas.org/en/stable/docs/reference/api/geopandas.GeoSeries.length.html

# Return the number of boundarys of a Polygon (aproximmation to perimeter). Return only for Polygons, to Multigeometry (regions with multi polygons) need a treatment to calculate
def get_boundarys_number(row):
  if row.geometry:
    multi = row.geometry.type.startswith("Multi")

    if multi:
      # n =0
      return "Multipolygon"
      # inter over all parts of geometry
      # for part in row.geometry:
        # n = n + len(part.exterior.coords)

    else:
      n = len(row.geometry.exterior.coords)

    return n

  else:
    return None

de_para_conj_["MUN_NUMBER_OF_BOUNDARYS"] = de_para_conj_.apply(get_boundarys_number, axis=1)
de_para_conj_["MUN_NUMBER_OF_BOUNDARYS"]

# Return the lenght (perimeters) of each geometry
de_para_conj_["LENGTH"] = de_para_conj_.geometry.length

de_para_conj_["AREA"] = de_para_conj_.geometry.area

de_para_conj_

de_para_conj_.to_file(base_path + "Ordens_servico/de_para_und_cons_.json", driver='GeoJSON')

