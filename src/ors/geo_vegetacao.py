# -*- coding: utf-8 -*-
"""geo_vegetacao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D2i7h7u39MXLoLiMNUGoi-0YSHI5A0R2

Validacao da leitura dos dados de kml das bases que contem as informacoes de vegetacao. Sendo estas informacoes a classificação morfológica realizada pelo IBGE e pela porcentagem de cobertura arbórea coletada do Satelite MODIS e disponibilizada pelo INMET.
"""

! pip install geotable  # Library to read the kmz file
! pip install geopandas # https://geopandas.org/en/stable/docs/user_guide/io.html
! pip install rasterio # Library to transform geotiff to geojson file

# libraries
import csv
import pandas as pd
import os
import rasterio
# import ckan
import requests
import geopandas as gpd
import numpy as np
import urllib
import time
import geotable
import sys
import ast
import codecs
from zipfile import ZipFile
import fiona

pd.set_option('display.max_columns', None)

# Conecta o serviço com o Drive
from google.colab import drive
drive.mount('/content/drive')

os.environ['ROOT'] = '/content/drive/MyDrive/Mestrado/Ordens_servico/'
base_path = os.environ.get("ROOT")

year = 2021

# Raiz
! ls '/content/drive/MyDrive/Mestrado/Ordens_servico/Ordens_servico'

"""## Geoinformation IBGE

É sabido que a quantidade áreas arborisadas tem forte influências em interrupções na linha de transmisssão. O IBGE disponibiliza o perfil de vegetação do Brasil, realizando a classificação de localidades com perfis de vegetação parecidos. Dessa forma, é avaliada a partir de cada conjunto de unidades consumidoras o tipo de vegetação predominante. Quando há mais de um tipo, é escolhido o de maior área.
"""

# Read the eletric sets data
de_para_conj = gpd.read_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_mun.json", driver='GeoJSON')
de_para_conj.shape

t_g = gpd.read_file(base_path + "Ordens_servico/Vegetacao/Vegetacao_5000.shp")

t_g

# Check the amount of unique informations
len(t_g.DSC_CLASS_.unique())

t_g.plot(figsize=(20,10))

t_g

de_para_conj["centroid"] = de_para_conj.geometry.to_crs('+proj=cea').centroid.to_crs(de_para_conj.crs)

poligons = t_g["geometry"].values
veg_areas = t_g["VAL_AREA_K"].values
vegs_class = t_g["DSC_CLASS_"].values

def get_class_veg(centroid):

  area = 0
  veg = None
  for poligon, veg_area, veg_class in zip(poligons, veg_areas, vegs_class):
    if poligon.contains(centroid):
      if veg_area > area:
        veg = veg_class
        area = veg_area

  return veg

de_para_conj["veg_class"]  = de_para_conj["centroid"].apply(get_class_veg)

de_para_conj.shape

# Check the amount of null data
de_para_conj[de_para_conj.veg_class.isnull()].shape[0]

# Centroid column was preventing to save the file
de_para_conj = de_para_conj.drop(columns='centroid')

de_para_conj.to_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_mun_veg.json", driver='GeoJSON')

"""## Geoinformation INPE"""

de_para_conj_ = gpd.read_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_mun_veg.json", driver='GeoJSON')
tree_cover = pd.read_csv(base_path + "Ordens_servico/geo_reference/raster_data.csv")

tree_cover

gdf = gpd.GeoDataFrame(
    tree_cover, geometry=gpd.points_from_xy(x=tree_cover.x, y=tree_cover.y)
)

gdf.head(2000).plot()

# Filter all the cases without information - (code -9999)
gdf = gdf[~(gdf.data == -9999)]
gdf

gdf.head(45)

# Por conta do tamanho do conjunto de dados para o teste pega de forma aleatoria 1% da base
gdf = gdf.sample(1000000)

gdf

join_left_df = gdf.sjoin(de_para_conj_, how="inner", predicate='within')

join_left_df = join_left_df[["IdeConjUndConsumidoras", "DscConjUndConsumidoras", "data"]]

join_left_df_grp = join_left_df.groupby("IdeConjUndConsumidoras")["data"].mean()

de_para_conj_

# Include information of percentage tree cover in the sets dataset
de_para_conj_ = de_para_conj_.merge(pd.DataFrame(join_left_df_grp), how='left', on='IdeConjUndConsumidoras')

de_para_conj_ = de_para_conj_.rename(columns={"data": "percent_tree_cover"})

# Completa os casos sem a cobertura de vegetacao com a media
de_para_conj_.loc[de_para_conj_.percent_tree_cover.isnull(), ["percent_tree_cover"]] = de_para_conj_["percent_tree_cover"].mean()

de_para_conj_

de_para_conj_.to_file(base_path + "Ordens_servico/de_para_und_cons_unit_med_mun_veg_t_cover.json", driver='GeoJSON')

"""## Inclui as informacoes geograficas (caracteristica geograficas) nas informacoes de conjuntos

Sao adicionados o raio, o perimetro e a area de cada conjunto

---


"""